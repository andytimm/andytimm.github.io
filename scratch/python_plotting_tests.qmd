---
title: "Python Plotting Tests"
editor: visual
---

```{python}
import torch
import numpy as np
import matplotlib.pyplot as plt

xlim = ylim = 4

def density(z):
  u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
  u = u - torch.log(
      torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
      + torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
  )
  return u

x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))

u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
      torch.exp(-0.5 * ((Z[:, 0] - 2) / 0.6) ** 2)
      + torch.exp(-0.5 * ((Z[:, 0] + 2) / 0.6) ** 2))

U = torch.exp(-density(Z))
U = U.reshape(shape)

U.size()
U

x
```


```{python}



def U_1(z):
  u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
  u = u - torch.log(
      torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
      + torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
  )
  return u

def plot_density(density, xlim=4, ylim=4, ax=None, cmap="Purples"):
  x = y = np.linspace(-xlim, xlim, 300)
  X, Y = np.meshgrid(x, y)
  shape = X.shape
  X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
  Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
  U = torch.exp(-density(Z))
  U = U.reshape(shape)
  if ax is None:
      fig = plt.figure(figsize=(7, 7))
      ax = fig.add_subplot(111)
  
  ax.set_xlim(-xlim, xlim)
  ax.set_ylim(-xlim, xlim)
  ax.set_aspect(1)
  
  ax.pcolormesh(X, Y, U, cmap=cmap, rasterized=True)
  ax.tick_params(
      axis="both",
      left=False,
      top=False,
      right=False,
      bottom=False,
      labelleft=False,
      labeltop=False,
      labelright=False,
      labelbottom=False,
  )
  return ax

plot_density(U_1)
```

```{python}
def U_1(z):
                u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
                u = u - torch.log(
                    torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
                    + torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
                )
                return u
              
test = U_1(torch.randn(128,2, 2))

test

#torch.randn(2, 2)

```

```{python}
torch_posterior.shape

# Unlike above, where his function takes a batch and batch norms them in 1 x 2 x 2,
# I think I need to just return
torch_posterior[128.3,128.4]
```

```{python}
def interpolate_tensor(tensor, x, y):
# Get the dimensions of the tensor
  height, width = tensor.shape
  
  # Calculate the indices of the four surrounding elements
  x1 = int(x)
  x2 = x1 + 1
  y1 = int(y)
  y2 = y1 + 1
  
  # Check if the indices are within the tensor boundaries
  if x1 >= width - 1 or y1 >= height - 1:
    return None
  
  # Calculate the weight for interpolation
  weight_x2 = x - x1
  weight_x1 = 1 - weight_x2
  weight_y2 = y - y1
  weight_y1 = 1 - weight_y2
  
  # Perform interpolation
  value = (
      tensor[y1, x1] * weight_x1 * weight_y1 +
      tensor[y1, x2] * weight_x2 * weight_y1 +
      tensor[y2, x1] * weight_x1 * weight_y2 +
      tensor[y2, x2] * weight_x2 * weight_y2
  )
  
  return value
    
tensor = torch.tensor([[1, 2, 3],
                         [4, 5, 6],
                         [7, 8, 9]])

# Interpolate at continuous coordinates
x = 1.5
y = 2.2
interpolated_value = interpolate_tensor(tensor, x, y)

print(interpolated_value)
```

