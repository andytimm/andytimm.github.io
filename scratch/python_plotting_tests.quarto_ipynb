{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Python Plotting Tests\"\n",
        "editor: visual\n",
        "eval: False \n",
        "---"
      ],
      "id": "ab8cfc10"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import torch\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "xlim = ylim = 4\n",
        "\n",
        "def density(z):\n",
        "  u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2\n",
        "  u = u - torch.log(\n",
        "      torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)\n",
        "      + torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)\n",
        "  )\n",
        "  return u\n",
        "\n",
        "x = y = np.linspace(-xlim, xlim, 300)\n",
        "X, Y = np.meshgrid(x, y)\n",
        "shape = X.shape\n",
        "X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))\n",
        "Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))\n",
        "\n",
        "u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2\n",
        "u = u - torch.log(\n",
        "      torch.exp(-0.5 * ((Z[:, 0] - 2) / 0.6) ** 2)\n",
        "      + torch.exp(-0.5 * ((Z[:, 0] + 2) / 0.6) ** 2))\n",
        "\n",
        "U = torch.exp(-density(Z))\n",
        "U = U.reshape(shape)\n",
        "\n",
        "U.size()\n",
        "U\n",
        "\n",
        "x"
      ],
      "id": "f9ac6cbd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def U_1(z):\n",
        "  u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2\n",
        "  u = u - torch.log(\n",
        "      torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)\n",
        "      + torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)\n",
        "  )\n",
        "  return u\n",
        "\n",
        "def plot_density(density, xlim=4, ylim=4, ax=None, cmap=\"Purples\"):\n",
        "  x = y = np.linspace(-xlim, xlim, 300)\n",
        "  X, Y = np.meshgrid(x, y)\n",
        "  shape = X.shape\n",
        "  X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))\n",
        "  Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))\n",
        "  U = torch.exp(-density(Z))\n",
        "  U = U.reshape(shape)\n",
        "  if ax is None:\n",
        "      fig = plt.figure(figsize=(7, 7))\n",
        "      ax = fig.add_subplot(111)\n",
        "  \n",
        "  ax.set_xlim(-xlim, xlim)\n",
        "  ax.set_ylim(-xlim, xlim)\n",
        "  ax.set_aspect(1)\n",
        "  \n",
        "  ax.pcolormesh(X, Y, U, cmap=cmap, rasterized=True)\n",
        "  ax.tick_params(\n",
        "      axis=\"both\",\n",
        "      left=False,\n",
        "      top=False,\n",
        "      right=False,\n",
        "      bottom=False,\n",
        "      labelleft=False,\n",
        "      labeltop=False,\n",
        "      labelright=False,\n",
        "      labelbottom=False,\n",
        "  )\n",
        "  return ax\n",
        "\n",
        "plot_density(U_1)"
      ],
      "id": "b4b9c5d9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def U_1(z):\n",
        "                u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2\n",
        "                u = u - torch.log(\n",
        "                    torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)\n",
        "                    + torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)\n",
        "                )\n",
        "                return u\n",
        "              \n",
        "test = U_1(torch.randn(128,2, 2))\n",
        "\n",
        "test\n",
        "\n",
        "#torch.randn(2, 2)"
      ],
      "id": "599e2662",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import torch\n",
        "\n",
        "def interpolate_tensor(tensor, coords):\n",
        "    # Get the dimensions of the tensor\n",
        "    height, width = tensor.shape\n",
        "\n",
        "    # Separate x and y coordinates from the input tensor\n",
        "    x = coords[:, 0]\n",
        "    y = coords[:, 1]\n",
        "\n",
        "    # Calculate the indices of the four surrounding elements\n",
        "    x1 = x.floor().clamp(max=width - 1).long()\n",
        "    x2 = x1 + 1\n",
        "    y1 = y.floor().clamp(max=height - 1).long()\n",
        "    y2 = y1 + 1\n",
        "\n",
        "    # Calculate the weight for interpolation\n",
        "    weight_x2 = x - x1.float()\n",
        "    weight_x1 = 1 - weight_x2\n",
        "    weight_y2 = y - y1.float()\n",
        "    weight_y1 = 1 - weight_y2\n",
        "\n",
        "    # Perform interpolation\n",
        "    value = (\n",
        "        tensor[y1.clamp(max=height - 1), x1.clamp(max=width - 1)] * weight_x1 * weight_y1 +\n",
        "        tensor[y1.clamp(max=height - 1), x2.clamp(max=width - 1)] * weight_x2 * weight_y1 +\n",
        "        tensor[y2.clamp(max=height - 1), x1.clamp(max=width - 1)] * weight_x1 * weight_y2 +\n",
        "        tensor[y2.clamp(max=height - 1), x2.clamp(max=width - 1)] * weight_x2 * weight_y2\n",
        "    )\n",
        "\n",
        "    return value\n",
        "\n",
        "# Create a sample PyTorch tensor\n",
        "tensor = torch.tensor([[1, 2, 3],\n",
        "                       [4, 5, 6],\n",
        "                       [7, 8, 9]])\n",
        "\n",
        "# Create a tensor with x and y coordinates\n",
        "coords = torch.tensor([[1.5, 2.2],\n",
        "                       [0.2, 1.7]])\n",
        "\n",
        "# Interpolate at continuous coordinates\n",
        "interpolated_values = interpolate_tensor(tensor, coords)\n",
        "\n",
        "print(interpolated_values)\n"
      ],
      "id": "e6694aa8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "unique_values, counts = torch.unique(torch_posterior, return_counts=True)\n",
        "\n",
        "# Print the unique values and their counts\n",
        "for value, count in zip(unique_values, counts):\n",
        "    print(f\"Value: {value}, Count: {count}\")"
      ],
      "id": "f996931b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fig, ax = plt.subplots()\n",
        "\n",
        "# Plot the tensor values\n",
        "ax.imshow(torch_posterior.cpu(), cmap='viridis')\n",
        "\n",
        "# Show the colorbar\n",
        "plt.colorbar()\n",
        "\n",
        "# Show the plot\n",
        "plt.show()"
      ],
      "id": "2d81e761",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "batch = torch.zeros(size=(batch_size, 2)).normal_(mean=0, std=1)\n",
        "batch2 = torch.zeros(size=(batch_size, 2)).normal_(mean=150, std=30)\n",
        "\n",
        "def two_moons_density(z):\n",
        "  x = z[:, 0]\n",
        "  y = z[:, 1]\n",
        "  d = torch.sqrt(x**2 + y**2)\n",
        "  density = torch.exp(-0.2 * d) * torch.cos(4 * np.pi * d)\n",
        "  return density\n",
        "\n",
        "def ring_density(z):\n",
        "    exp1 = torch.exp(-0.5 * ((z[:, 0] - 2) / 0.8) ** 2)\n",
        "    exp2 = torch.exp(-0.5 * ((z[:, 0] + 2) / 0.8) ** 2)\n",
        "    u = 0.5 * ((torch.norm(z, 2, dim=1) - 4) / 0.4) ** 2\n",
        "    u = u - torch.log(exp1 + exp2 + 1e-6)\n",
        "    return u\n",
        "\n",
        "two_moons_density(batch).min()\n",
        "ring_density(batch).min()\n",
        "ring_density(batch).max()"
      ],
      "id": "a3e0e895",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def interpolate_tensor(tensor, z):\n",
        "    # Get the dimensions of the tensor\n",
        "    height, width = tensor.shape[:2]\n",
        "\n",
        "    # Scale and shift the normal draws to match the image coordinates\n",
        "    x = (z[:, 0] * 150 + 150).clamp(0, width - 1).long()\n",
        "    y = (z[:, 1] * 150 + 150).clamp(0, height - 1).long()\n",
        "\n",
        "    # Calculate the indices of the four surrounding elements\n",
        "    x1 = x.floor()\n",
        "    x2 = x1 + 1\n",
        "    y1 = y.floor()\n",
        "    y2 = y1 + 1\n",
        "\n",
        "    # Calculate the weight for interpolation\n",
        "    weight_x2 = x - x1.float()\n",
        "    weight_x1 = 1 - weight_x2\n",
        "    weight_y2 = y - y1.float()\n",
        "    weight_y1 = 1 - weight_y2\n",
        "\n",
        "    # Perform interpolation\n",
        "    value = (\n",
        "        tensor[y1.clamp(max=height - 1), x1.clamp(max=width - 1)] * weight_x1 * weight_y1 +\n",
        "        tensor[y1.clamp(max=height - 1), x2.clamp(max=width - 1)] * weight_x2 * weight_y1 +\n",
        "        tensor[y2.clamp(max=height - 1), x1.clamp(max=width - 1)] * weight_x1 * weight_y2 +\n",
        "        tensor[y2.clamp(max=height - 1), x2.clamp(max=width - 1)] * weight_x2 * weight_y2\n",
        "    )\n",
        "\n",
        "    return value\n",
        "  \n",
        "batch = torch.zeros(size=(batch_size, 2)).normal_(mean=0, std=1)\n",
        "interpolate_tensor(torch_posterior, batch)\n",
        "\n",
        "#ring_density(batch)"
      ],
      "id": "a805d796",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#ring_density(batch)\n",
        "#interpolate_tensor(torch_posterior,batch2)\n",
        "batch2"
      ],
      "id": "12fcd665",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fig, ax = plt.subplots()\n",
        "\n",
        "# Plot the tensor values\n",
        "ax.imshow(ring_density(batch).cpu(), cmap='viridis')\n",
        "\n",
        "# Show the colorbar\n",
        "plt.colorbar()\n",
        "\n",
        "# Show the plot\n",
        "plt.show()"
      ],
      "id": "47bdd836",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "interpolate_tensor(torch_posterior, torch.tensor([[81,156.5]]))\n",
        "\n",
        "torch_posterior[81,157]\n",
        "\n",
        "indices = torch.nonzero(torch_posterior != 0)\n",
        "\n",
        "len(indices)\n",
        "\n",
        "# Print the pairs of indices\n",
        "#for idx in indices:\n",
        "#    i, j = idx\n",
        "#    print(f\"Pair of indices: ({i}, {j})\")"
      ],
      "id": "d9e928ea",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "test = MultivariateNormal(torch.zeros(2), torch.eye(2))\n",
        "\n",
        "test.sample()"
      ],
      "id": "11c53f83",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import os\n",
        "import imageio\n",
        "\n",
        "\n",
        "def make_gif_from_train_plots(fname: str) -> None:\n",
        "  # Hiding the directory when commiting, but easy to infer rihgt path\n",
        "    png_dir = \"\"\n",
        "    images = []\n",
        "    sort = sorted(os.listdir(png_dir))\n",
        "    for file_name in sort[1::1]:\n",
        "        if file_name.endswith(\".png\"):\n",
        "            file_path = os.path.join(png_dir, file_name)\n",
        "            images.append(imageio.imread(file_path))\n",
        "\n",
        "    imageio.mimsave(\"gifs/\" + fname, images, duration=0.05)\n",
        "    \n",
        "make_gif_from_train_plots(\"32_layer.gif\")"
      ],
      "id": "9fd830eb",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Python311\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}