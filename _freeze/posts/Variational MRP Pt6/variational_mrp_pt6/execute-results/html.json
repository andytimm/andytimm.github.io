{
  "hash": "3d08a71b502c93e28862097d3ec4abd5",
  "result": {
    "markdown": "---\nlayout: post\ntitle: Variational Inference for MRP with Reliable Posterior Distributions\nsubtitle: Part 6- Diagnostics\ndate: 2023-06-17\ndraft: True\ncategories:\n  - MRP\n  - Variational Inference\n  - Diagnostics\n---\n\n   \n   \nThis is section 6 in my series on using Variational Inference to speed up relatively complex Bayesian models like Multilevel Regression and Poststratification without the approximation being of disastrously poor quality. \n\nThe general structure for this post and the posts around it will be to describe a problem with VI, and then describe how that problem can be fixed to some degree. Collectively, all the small improvements in these four posts will go a long way towards more robust variational inference. I'll also have a grab bag at the end of other interesting ideas from the literature I think are cool, but maybe not as important or interesting to me as the 3 below.\n\nIn the [last post](https://andytimm.github.io/posts/Variational%20MRP%20Pt5/variational_mrp_5.html) we looked at normalizing flows, a way to leverage neural networks to learn significantly\nmore expressive variational families in a way that adapt to specific problems.\n\nIn this post, we'll explore different diagnostics for variational inference,\nranging from simple statistics that are easy to calculate as we fit our approximation to solving the problem\nin parallel with MCMC to compare and contrast. Some recurring themes will be \naiming to be precise about what constitutes failure under each diagnostic tool,\nand providing intuition building examples where each diagnostic will fail to\ndo anything useful. While no single diagnostic provides strong guarantees of\nvariational inference's correctness on their own, taken together the tools\nin this post broaden our ability to know when our models fall short.\n\nThe rough plan for the series is as follows:\n\n1.  Introducing the Problem- Why is VI useful, why VI can produce spherical cows\n2.  How far does iteration on classic VI algorithms like mean-field and full-rank get us?\n3.  Problem 1: KL-D prefers exclusive solutions; are there alternatives?\n4.  Problem 2: Not all VI samples are of equal utility; can we weight them cleverly?\n5.  Problem 3: How can we get deeply flexible variational approximations; are Normalizing Flows the answer?\n6.  **(This post)** Problem 4: How can we know when VI is wrong? Are there useful error bounds?\n7.  Putting the workflow all together\n\n# Looking at our loss function\n\nOne logical place to start with diagnostics is to discuss what we can and can't\ninfer from our optimization objectives like an ELBO or CUBO.\n\nIn training a model with variational inference some common stopping rule choices\nare either to just run optimization for a fixed number of iterations, or to\nstop when relative changes in the loss have slowed, indicating convergence of\nthe optimization to a local minimum. So we can at least look at changes in\nthe ELBO/CUBO/other loss to know if our approximation has hit a local minimum yet.\n\nUnfortunately, that's about all monitoring the loss can tell us. Recall that An unknown,\nmultiplicative constant exists in $p(z,x) \\propto p(z|x)$ that changes as\nreparameterize our model; thus, we can't compare two different models on the\nsame objective and expect their ELBO or similar loss values to be comparable. So\nthe typical ML strategy of \"which model achieves lower loss\" is pretty much\nout here.\n\nAlso, the loss values themselves aren't particularly meaningful: there's no\nway to interpret a given ELBO as indicating a good approximation, for example. This\ngenerally stems from our bounds being bounds, not directly optimizing the quantity\nwe want to optimize. While they're definitely degenerate cases, there are even some\nfun counter examples I'll show in a second where you can make the ELBO/CUBO arbitrarily low, while\nstill allowing the posterior mean or standard deviation to be arbitrarily wrong!\n\n# The majesty of $\\hat{k}$\n\nSo if we can't just look at our loss, what can we look at? One broadly applicable\ndiagnostic tool is $\\hat{k}$, which we already introduced in the post on using\nimportance sampling to improve variational inference.\n\nAs a several sentence refresher, Pareto smoothed importance sampling (PSIS) proposes to stabilize\nimportance ratios $r(\\theta)$ used in importance sampling by modeling the tail of the distribution\nas a generalized Pareto distribution:\n\n$$\n\\frac{1}{\\sigma} \\left(1 + k\\frac{r - \\tau}{\\sigma} \\right)^{-1/k-1}\n$$\nwhere $\\tau$ is a lower bound parameter, which in our case defines how many ratios from the tail\nwe'll actually model. $\\sigma$ is a scale parameter, and $k$ is a unconstrained shape parameter.\n\nTo see\nhow this provides a natural diagnostic for importance sampling, it's useful to know that importance sampling depends on how many moments $r(\\theta)$ has- for example, if at least two moments exist, the vanilla IS estimator has finite variance (which is obviously required, but no guarantee of performance since it might be finite but massive). The GPD\nhas $k^{-1}$ finite fractional moments when $k > 0$. [Vehtari et Al. (2015)](https://arxiv.org/abs/1507.02646) show through extensive theoretical digging and simulations that PSIS\nworks fantastically when $\\hat{k} < .5$. and acceptably if $.5 < \\hat{k} < .7$. Beyond $\\hat{k} = .7$ there the number of samples needed rapidly become impractically large.\n\nWhy should we think $\\hat{k}$ is a relevant diagnostic for variational inference? [Chaterjee and Draconis (2018)](https://arxiv.org/abs/1511.01437)\nshowed that for a given accuracy, how big $S$ needs to be for importance sampling\nmore broadly depends on how close $q(x)$ is to $p(x)$ in KL distance- we need to\nsatisfy $log(S) \\geq \\mathbb{E}_{\\theta \\sim q(x)}[r(\\theta)log(r(\\theta))]$ to\nget reasonable accuracy. So a good $\\hat{k}$ indicates importance sampling is\nfeasible, which in tern indicates that $q(x)$ is likely close to $p(x)$ in KL Divergence- exactly what we're hoping to get at!\n\nFleshing out the use of $\\hat{k}$ as a VI diagnostic was done by [Yao et al. (2018)](https://arxiv.org/abs/1802.02538),\nwho generally show that high values of $\\hat{k}$ do generally map onto posterior approximations\nwith variational inference being quite poor. This is really useful, and generally\nmaps well on to my experience- if $\\hat{k}$ is bigger than .7, you probably\nneed to go back to the drawing board on how you're fitting your VI.\n\nWhat I want to stress though, is that the inverse isn't broadly true- a low $\\hat{k}$\nisn't necessarily a guarantee the VI approximation is good. Let's look at a couple\ndifferent ways this can happen.\n\n## Problem Case 1: Importance sampling $\\neq$ direct variational inference\n\nWe should keep in mind that $\\hat{k}$ is ultimately a diagnostic tool for\nimportance sampling, and in cases where the needs of importance sampling\nand simple variational inference diverge, $\\hat{k}$ can give a misleading answer.\n\nLet's re-use an example from the importance sampling post to illustrate this.\nWhat happens if we approximate the red distribution below with the green one?\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmixture %>% ggplot(aes(x = normals)) +\n  geom_density(aes(x = normals), color = \"red\") +\n  geom_density(aes(x = mean_seeking_kl), color = \"green\") + ggtitle(\"The green approxmiation is great for IS, terrible on it's own\") +\n  xlab(\"\")\n```\n\n::: {.cell-output-display}\n![](variational_mrp_pt6_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nThe green distribution here is a prime candidate to importance sample to approximate\nthe red one- it coves all the needed mass, and we can massively down weight\nthe irrelevant points in the center. On the other hand, this'd be a really,\nreally bad variational approximation to use raw, since it has a ton of mass\nbetween the two modes which will blow up our loss. Because the needs of PSIS-based\nestimators and unadjusted VI diverge, $\\hat{k}$ is low, but the approximation\nwould be pretty bad:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimportance_ratios <- tibble(\nq_x = rnorm(200000,9,4),\np_x = c(rnorm(100000,3,1),rnorm(100000,15,2)),\nratios = (.5*(dnorm(q_x,3,1)) + .5*(dnorm(q_x,15,2)))/dnorm(q_x,9,4))\n\npsis_result <- psis(log(importance_ratios$ratios),\n                       r_eff = NA)\n\npsis_result$diagnostics$pareto_k\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1.737515\n```\n:::\n:::\n\n\nSo our $\\hat{k}$ says everything is beautiful, but in reality it's really\nonly a happy time for PSIS, not the raw VI estimator. This ultimately isn't\nthe most concerning failure mode: if you do the work to calculate $\\hat{k}$,\nyou're pretty much ready to use PSIS to improve your variational inference anyway. That \nsaid, this should provide intuition that $\\hat{k}$ isn't in general super well equipped to\ntell you much about non-IS augmented VI.\n\n## Problem Case 2: $\\hat{k}$ is a local diagnostic\n\n$\\hat{k}$ inherits a common issue with most KL Divergence adjacent metrics: it's\nultimately something we evaluate locally, so if there's a part of the posterior totally\nunknown to our $q(x)$, it won't be able to tell you what you're missing.\n\nWe already used 1 example from the importance sampling post, so let's keep that\nmoving. What do you think will happen with $\\hat{k}$ with the green approximation\nbelow that misses a whole mode?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmixture %>% ggplot(aes(x = normals)) +\n  geom_density(aes(x = normals), color = \"red\") +\n  geom_density(aes(x = mode_seeking_kl), color = \"green\") + ggtitle(\"We're missing a whole mode here\") +\n  xlab(\"\")\n```\n\n::: {.cell-output-display}\n![](variational_mrp_pt6_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nIf you guessed $\\hat{k}$ will say everything is perfect when it's not, you're\ncorrect:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsecond_importance_ratios <- tibble(\nq_x = rnorm(200000,3.5,1),\np_x = c(rnorm(100000,3,1),rnorm(100000,15,2)),\n# Notice: these density calls are at the points defined by q(x)!\nratios = (.5*(dnorm(q_x,3,1)) + .5*(dnorm(q_x,15,2)))/dnorm(q_x,3.5,1))\n\npsis_result_2 <- psis(log(second_importance_ratios$ratios),\n                       r_eff = NA)\n\npsis_result_2$diagnostics$pareto_k\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.07343881\n```\n:::\n:::\n\n\nThat's... not great. Since we evaluate the importance ratio and thus eventually  $\\hat{k}$\nat the collection of values in $q(x)$, the diagnostic has no real way to know\nwe're missing an entire mode, and unlike in the above case there's no easy fix here.\n\nAnother interesting question this example raises is what happens in high dimensions,\nwhere it's much less intuitive what \"missing one or several modes\" looks like. Just\nby increasing the sd of the normal $q(x)$ a little in the example, we see a sudden,\nlarge increase in $\\hat{k}$;\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthird_importance_ratios <- tibble(\nq_x = rnorm(200000,3.5,2),\np_x = c(rnorm(100000,3,1),rnorm(100000,15,2)),\nratios = (.5*(dnorm(q_x,3,1)) + .5*(dnorm(q_x,15,2)))/dnorm(q_x,3.5,2))\n\npsis_result_3 <- psis(log(third_importance_ratios$ratios),\n                       r_eff = NA)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some Pareto k diagnostic values are too high. See help('pareto-k-diagnostic') for details.\n```\n:::\n\n```{.r .cell-code}\npsis_result_3$diagnostics$pareto_k\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.70381\n```\n:::\n:::\n\n\nsimilar sudden shifts in $\\hat{k}$ can frequently occur as you\nincrease the dimension of a posterior you're approximating- intuitively, the mass\nyou do and don't know about becomes much harder to keep track of in high dimensions and\nfor complex posteriors. This can lead to $\\hat{k}$ being a bit less stable than\nyou'd like over different initializations or other slight modifications of a VI\nmodel, with this pattern being common both in my own applications and documented in several\npapers like [Wang et al. (2023)](https://arxiv.org/abs/2302.12419)'s testing.\n\n\n## Problem Case 3: $\\hat{k}$ is a joint posterior level tool\n\nA final, more conceptual problem with $\\hat{k}$ that [Yao et al. (2018)](https://arxiv.org/abs/1802.02538) point out is that it's ultimately a diagnostic\nof the joint posterior, not the specific marginal or summary statistic you may ultimately care about.\n\nVariational inference is hard: we often know that the overall posterior approximation is deeply\nflawed, but it may be up to the task of representing some metrics we care about correctly enough. For \nexample, in the MRP example I introduced earlier in the series, the mean-field\nvariational inference fit was reasonable at representing the state-level means, but garbage at\npretty much anything related to uncertainty. The $\\hat{k}$ from that model was greater than\n2, so we clearly know the broader posterior approximation was poor, but $\\hat{k}$\nmight be a false positive sign if what you really care about was just the means. For\nthe most complicated posteriors, we should expect to spend a lot of time in this\nfeeling of \"some parts of the posterior may be good enough\", so this is a useful\ntrap to know about.\n\n...Let's step back for a second. Since I introduced PSIS with a bunch of cases\nwhere it falls short in surprising ways, I do want to emphasize it is a very useful *heuristic* diagnostic tool\nin general. Large $\\hat{k}$ tells you something is very likely wrong with your joint posterior,\nand that's generally practically helpful information. Where we need to be cautious\nis in inferring whether the wrongness $\\hat{k}$ picks up on is something we care about,\nand also in remembering that low $\\hat{k}$ doesn't provide gaurantees of correctness.\n\n\n# Wasserstein Bounds\n\n# MCMC based diagnostics; what's old is new again\n\n## MCMC can be practically useful even when slow\n\n## TADDAA\n\n# Diagnostics that don't spark joy",
    "supporting": [
      "variational_mrp_pt6_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}