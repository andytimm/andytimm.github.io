{
  "hash": "c132a5679c719b2172d3063b34080b35",
  "result": {
    "markdown": "---\nlayout: post\ntitle: Variational Inference for MRP with Reliable Posterior Distributions\nsubtitle: Part 2\ndate: 2022-10-28\ndraft: True\ncategories:\n- MRP\n- BART\n- Variational Inference\n---\n\n\nThis is the second post in my series on using Variational Inference to speed up relatively complex Bayesian like Multilevel Regression and Poststratification models without the approximation being of disastrously poor quality. In the last post, I laid out why such reformulating the Bayesian inference problem as optimization might be desirable, but previewed why this might be quite hard to find high quality approximations amenable to optimization. I then introduced our running example (predicting national/sub-national opinion on an abortion question from the CCES using MRP), and gave an initial introduction to a version of Variational Inference where we maximize the Evidence Lower Bound (ELBO) as an objective, and do so using a mean-field Gaussian approximation. We saw that with 60k examples, this took about 8 hours to fit with MCMC, but 144 seconds (!) with VI.\n\nIn this post, we'll explore the shortcomings of this initial approximation, and take a first pass at trying to better with a more complex (full rank) variational approximation. The goal is to get a better feel for what failing models could look like, at least in this relatively simple case.\n\nThe rough plan for the series is as follows:\n\n1.  [Introducing the Problem- Why is VI useful, why VI can produce spherical cows](https://andytimm.github.io/posts/Variational%20MRP%20Pt1/variational_mrp_pt1.html)\n2.  **(This post)** How far does iteration on classic VI algorithms like mean-field and full-rank get us?\n3.  Some theory on why posterior approximation with VI can be so poor\n4.  Seeing if some more sophisticated techniques like normalizing flows help\n\n\n::: {.cell}\n\n:::\n\n\n# The disclaimer\n\nOne sort of obvious objections to how I've set up this series is \"Why not talk about theory on why VI approximations can be poor before trying stuff?\". While in practice I did read a lot of the papers for the next post before writing this one, I think there's a lot of value is looking at failed solutions to a problem to build up intuition about what our failure mode looks like, and what it might require to get it right. <Example or two to tease this once I have them>.\n\n# Toplines\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeanfield_60k <- readRDS(\"fit_60k_meanfield.rds\")\nmcmc_60k <- readRDS(\"fit_60k_mcmc.rds\")\n\n# Meanfield \nepred_mat_mf <- posterior_epred(meanfield_60k, newdata = poststrat_df_60k, draws = 1000)\nmrp_estimates_vector_mf <- epred_mat_mf %*% poststrat_df_60k$n / \n                                              sum(poststrat_df_60k$n)\nmrp_estimate_mf <- c(mean = mean(mrp_estimates_vector_mf),\n                     sd = sd(mrp_estimates_vector_mf))\n\n\n# MCMC \nepred_mat_mcmc <- posterior_epred(mcmc_60k, newdata = poststrat_df_60k, draws = 1000)\nmrp_estimates_vector_mcmc <- epred_mat_mcmc %*% poststrat_df_60k$n /\n                                                  sum(poststrat_df_60k$n)\nmrp_estimate_mcmc <- c(mean = mean(mrp_estimates_vector_mcmc),\n                       sd = sd(mrp_estimates_vector_mcmc))\n\ncat(\"Meanfield MRP estimate mean, sd: \", round(mrp_estimate_mf, 3))\ncat(\"MCMC MRP estimate mean, sd: \", round(mrp_estimate_mcmc, 3))\n```\n:::\n\n\n|   | Mean  | SD  |\n|---|---|---|\n| MCMC  | 43.9%  |  .2% |\n| mean-field VI  |  43.7% | .2%  |\n\nStarting with basics, the toplines are pretty much identical, which is a good start. The minor difference here could easily be simulation error- from a few quick re-runs these\noften end up having matching means to 3 decimals.\n\n# State Level Estimates\n\nWhat happens if we produce state level estimates, similar to the plot last post\ncomparing MRP to a simple weighted estimate? Note that I'll steer away from\nthe MRP Case Study example here in a few ways. I'll use `tidybayes` for\nworking with the draws (more elegant than their loop based approach),\nand I'll use more draws (helps with simulation error in smaller states).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcmc_state_level <- poststrat_df_60k %>% add_epred_draws(mcmc_60k, ndraws = 1000)\nmfvi_state_level <- poststrat_df_60k %>% add_epred_draws(meanfield_60k, ndraws = 1000)\n\nmcmc_state_level %>% glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 12,000,000\nColumns: 13\nGroups: state, eth, male, age, educ, n, repvote, region, .row [12,000]\n$ state      <chr> \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\",…\n$ eth        <chr> \"White\", \"White\", \"White\", \"White\", \"White\", \"White\", \"Whit…\n$ male       <dbl> -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,…\n$ age        <chr> \"18-29\", \"18-29\", \"18-29\", \"18-29\", \"18-29\", \"18-29\", \"18-2…\n$ educ       <chr> \"No HS\", \"No HS\", \"No HS\", \"No HS\", \"No HS\", \"No HS\", \"No H…\n$ n          <dbl> 23948, 23948, 23948, 23948, 23948, 23948, 23948, 23948, 239…\n$ repvote    <dbl> 0.6437414, 0.6437414, 0.6437414, 0.6437414, 0.6437414, 0.64…\n$ region     <chr> \"South\", \"South\", \"South\", \"South\", \"South\", \"South\", \"Sout…\n$ .row       <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ .chain     <int> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ .iteration <int> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ .draw      <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ .epred     <dbl> 0.5771322, 0.5189677, 0.5483006, 0.5421404, 0.5417602, 0.55…\n```\n:::\n:::\n\n\nIf you haven't worked with `tidybayes` before, the glimpse above should help\ngive some intuition about the new shape of the data- we've take the 12,000 row\n`poststrat_df_60k`, and added a row per observation per draw, with the prediction\n(.epred) and related metadata. This gives\n12,000 x 1,000 = 12,000,000 million rows. This really isn't the most space\nefficient storage, but it allows for very elegant `dplyr` style manipulation of\nresults and quick exploration.\n\nLet's now plot and compare the 50 and 95% credible intervals by state between\nthe two models.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcmc_state_summary <- mcmc_state_level %>% \n                        # multiply each draw by it's cell's proportion of state N\n                        # this is the P in MRP\n                        group_by(state,.draw) %>%\n                        mutate(postrat_draw = sum(.epred*(n/sum(n)))) %>%\n                        group_by(state) %>%\n                        median_qi(postrat_draw, .width = c(.5,.95)) %>%\n                        mutate(model = \"mcmc\")\nmfvi_state_summary <- mfvi_state_level %>% \n                        group_by(state,.draw) %>%\n                        mutate(postrat_draw = sum(.epred*(n/sum(n)))) %>%\n                        group_by(state) %>%\n                        median_qi(postrat_draw, .width = c(.5,.95)) %>%\n                        mutate(model = \"MF-VI\")\n\ncombined_summary <- bind_rows(mcmc_state_summary,mfvi_state_summary)\n\ncombined_summary %>%\n  mutate(ordered_state = fct_reorder(combined_summary$state,\n                                     combined_summary$postrat_draw)) %>%\n  ggplot(aes(y = ordered_state,\n             x = postrat_draw,\n             xmin = .lower,\n             xmax = .upper,\n             color = model)) +\n  geom_pointinterval(position = position_dodge(1)) +\n  xlim(.25,.75) +\n  theme(legend.position=\"top\")\n```\n\n::: {.cell-output-display}\n![](Variational_MRP_pt2_files/figure-html/unnamed-chunk-4-1.png){width=768}\n:::\n:::\n\n... That looks concerning. What's happened here?\n\nWhat might you get wrong if you used the VI approximation for inference here? If you\nonly cared about the median estimate primarily, you might be ok with this effort.\nIf you care about uncertainty though, here's a non-exaustive list of concerns here:\n\n1.  Probably unimodal, smooth\nposterior distributions from MCMC have gone off-course to the point where the\nMedian/50/95% presentation no longer seems up to expressing the posterior shape\n(more on this in a second).\n2.   The MF-VI posteriors are often narrower in 50% or 95% CI- we'd on average\nunderestimate various types of uncertainty here.\n3.   Worse[^1], the MF-VI posterior's CIs aren't **consistently** narrower, either in\nthe sense they are always narrower, or that they tend to consistently distort the\nsame way. Sometimes both the 50% and 95% are just a small amount narrower than\nMCMC- the Michigan posterior attempt looks passable. Sometimes things are worse,\nwith 50% MFVI CIs almost as wide as the MCMC 95% interval- Wyoming shows such a \ndistortion. Sometimes the probability mass between 50% and 95% is confined\nto such a minuscule range it looks like I forgot to plot it. \n\nThat last point is\nparticularly important because it suggests there's no easy rule of thumb for\nmechanically correcting these intervals, or deciding which could be plausible\napproximations without the MCMC plot alongside to guide that process. We can't\nuse VI to save a ton of time, infer the intervals consistently need to x% be wider,\nand call it a day- we need to reckon more precisely with why they're distorted.\n\nLet's return now to the point about how the shape has gone wrong. Below is\na dot plot ([Kay et al., 2016](https://dl.acm.org/doi/10.1145/2858036.2858558))- each\npoint here represents about 1% of the probability mass. I enjoy this approach\nto posterior visualization when things are getting weird, as this clarifies a\nlot about the full shape of the posterior\ndistribution, making fewer smoothing assumptions like a density or eye plot might.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcmc_state_points <- mcmc_state_level %>% \n                        # multiply each draw by it's cell's proportion of state N\n                        # this is the P in MRP\n                        group_by(state,.draw) %>%\n                        summarize(postrat_draw = sum(.epred*(n/sum(n)))) %>%\n                        mutate(model = \"mcmc\")\nmfvi_state_points <- mfvi_state_level %>% \n                        group_by(state,.draw) %>%\n                        summarize(postrat_draw = sum(.epred*(n/sum(n)))) %>%\n                        mutate(model = \"MF-VI\")\n\ncombined_points <- mcmc_state_points %>%\n                      bind_rows(mfvi_state_points) %>%\n                      ungroup()\n\ncombined_points %>%\n  mutate(ordered_state = fct_reorder(combined_points$state,\n                                     combined_points$postrat_draw)) %>%\n  ggplot(aes(y = ordered_state,\n             x = postrat_draw,\n             color = model)) +\n     stat_dots(quantiles = 100) +\n     facet_wrap(~model) +\n     theme(legend.position=\"none\")\n```\n\n::: {.cell-output-display}\n![](Variational_MRP_pt2_files/figure-html/unnamed-chunk-5-1.png){width=768}\n:::\n:::\n\nEek. The closer to the individual draws we get, the less these two models seem to be\nproducing comparable estimates. This isn't me expressing an aesthetic preference\nfor smooth, unimodal distributions- the MFVI plots in this view imply beliefs\nlike \"support for this policy in Wyoming is overwhelmingly likely to fall in 1 of\n3 narrow ranges, all other values are unlikely\"[^2]. Other similar humorous claims\nare easy to find.\n\nStepping back for a second, if our use-case for this model takes pretty\nmuch any form of interest in quantifying uncertainty accurately, this is not\nan acceptable approximation. I could poke more holes, but I can more profitably\ndo that after I've explored some theory of why VI models struggle, and brought\nin some more sophisticated diagnostic tools than looking with our eyeballs[^3];\nso let's hold off on that.\n\n# Do more basic fixes solve anything?\n\nSo I've been billing this simple mean-field model as a first pass- I fit it on\nmore or less default `rstanarm` parameters. I think it's worth taking a moment\nto show that getting this approximation problem right isn't going to be solved\nwith low hanging fruit ideas, since that will motivate our need for better\ndiagnostics and more expressive approximations.\n\n\n## Lowering the tolerance\n\nSo we managed to structure our Bayesian inference problem as an optimization\nproblem. Can't we just optimize better? Maybe with more training the result\nwill be less bad?\n\nthe `tol_rel_obj` parameter control's the convergence tolerance on the relative\nnorm of the objective. In other words, it controls what Evidence Lower Bound\nvalue we consider accurate enough to stop at. The default is 0.01, which feels\na bit opaque, but let's try setting it way down to 1e-8 (1Mx lower), and\nfurther, let's increase the max iterations 10x. Then we can\nplot it alongside the MCMC estimates and original MF-VI attempt.\n\n\n::: {.cell warnings='false'}\n\n```{.r .cell-code}\ntic()\nfit_60k_1e8 <- stan_glmer(abortion ~ (1 | state) + (1 | eth) + (1 | educ) +\n                                      male + (1 | male:eth) + (1 | educ:age) +\n                                      (1 | educ:eth) + repvote + factor(region),\n  family = binomial(link = \"logit\"),\n  data = cces_all_df,\n  prior = normal(0, 1, autoscale = TRUE),\n  prior_covariance = decov(scale = 0.50),\n  adapt_delta = 0.99,\n  # Printing the ELBO every 1k draws\n  refresh = 1000,\n  tol_rel_obj = 1e-8,\n  algorithm = \"meanfield\",\n  seed = 605)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nChain 1: ------------------------------------------------------------\nChain 1: EXPERIMENTAL ALGORITHM:\nChain 1:   This procedure has not been thoroughly tested and may be unstable\nChain 1:   or buggy. The interface is subject to change.\nChain 1: ------------------------------------------------------------\nChain 1: \nChain 1: \nChain 1: \nChain 1: Gradient evaluation took 0.022 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 220 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Begin eta adaptation.\nChain 1: Iteration:   1 / 250 [  0%]  (Adaptation)\nChain 1: Iteration:  50 / 250 [ 20%]  (Adaptation)\nChain 1: Iteration: 100 / 250 [ 40%]  (Adaptation)\nChain 1: Iteration: 150 / 250 [ 60%]  (Adaptation)\nChain 1: Iteration: 200 / 250 [ 80%]  (Adaptation)\nChain 1: Success! Found best value [eta = 1] earlier than expected.\nChain 1: \nChain 1: Begin stochastic gradient ascent.\nChain 1:   iter             ELBO   delta_ELBO_mean   delta_ELBO_med   notes \nChain 1:    100       -40291.889             1.000            1.000\nChain 1:    200       -39947.669             0.504            1.000\nChain 1:    300       -39802.182             0.337            0.009\nChain 1:    400       -39776.283             0.253            0.009\nChain 1:    500       -39733.863             0.203            0.004\nChain 1:    600       -39733.198             0.169            0.004\nChain 1:    700       -39728.255             0.145            0.001\nChain 1:    800       -39784.557             0.127            0.001\nChain 1:    900       -39724.366             0.113            0.001\nChain 1:   1000       -39732.042             0.102            0.001\nChain 1:   1100       -39731.525             0.002            0.001\nChain 1:   1200       -39732.049             0.001            0.001\nChain 1:   1300       -39728.119             0.001            0.000\nChain 1:   1400       -39740.928             0.000            0.000\nChain 1:   1500       -39726.114             0.000            0.000\nChain 1:   1600       -39734.740             0.000            0.000\nChain 1:   1700       -39734.129             0.000            0.000\nChain 1:   1800       -39740.719             0.000            0.000\nChain 1:   1900       -39743.591             0.000            0.000\nChain 1:   2000       -39737.155             0.000            0.000\nChain 1:   2100       -39720.432             0.000            0.000\nChain 1:   2200       -39738.138             0.000            0.000\nChain 1:   2300       -39731.045             0.000            0.000\nChain 1:   2400       -39716.393             0.000            0.000\nChain 1:   2500       -39729.189             0.000            0.000\nChain 1:   2600       -39722.239             0.000            0.000\nChain 1:   2700       -39719.508             0.000            0.000\nChain 1:   2800       -39718.709             0.000            0.000\nChain 1:   2900       -39735.110             0.000            0.000\nChain 1:   3000       -39725.900             0.000            0.000\nChain 1:   3100       -39726.123             0.000            0.000\nChain 1:   3200       -39718.736             0.000            0.000\nChain 1:   3300       -39718.141             0.000            0.000\nChain 1:   3400       -39717.147             0.000            0.000\nChain 1:   3500       -39725.738             0.000            0.000\nChain 1:   3600       -39732.190             0.000            0.000\nChain 1:   3700       -39723.666             0.000            0.000\nChain 1:   3800       -39725.470             0.000            0.000\nChain 1:   3900       -39741.504             0.000            0.000\nChain 1:   4000       -39722.951             0.000            0.000\nChain 1:   4100       -39721.852             0.000            0.000\nChain 1:   4200       -39717.894             0.000            0.000\nChain 1:   4300       -39717.474             0.000            0.000\nChain 1:   4400       -39716.244             0.000            0.000\nChain 1:   4500       -39727.542             0.000            0.000\nChain 1:   4600       -39716.670             0.000            0.000\nChain 1:   4700       -39723.714             0.000            0.000\nChain 1:   4800       -39727.123             0.000            0.000\nChain 1:   4900       -39722.517             0.000            0.000\nChain 1:   5000       -39722.485             0.000            0.000\nChain 1:   5100       -39719.107             0.000            0.000\nChain 1:   5200       -39722.873             0.000            0.000\nChain 1:   5300       -39720.153             0.000            0.000\nChain 1:   5400       -39718.807             0.000            0.000\nChain 1:   5500       -39719.687             0.000            0.000\nChain 1:   5600       -39730.850             0.000            0.000\nChain 1:   5700       -39719.315             0.000            0.000\nChain 1:   5800       -39717.985             0.000            0.000\nChain 1:   5900       -39715.943             0.000            0.000\nChain 1:   6000       -39721.574             0.000            0.000\nChain 1:   6100       -39716.072             0.000            0.000\nChain 1:   6200       -39715.947             0.000            0.000\nChain 1:   6300       -39716.325             0.000            0.000\nChain 1:   6400       -39716.206             0.000            0.000\nChain 1:   6500       -39720.508             0.000            0.000\nChain 1:   6600       -39717.566             0.000            0.000\nChain 1:   6700       -39718.903             0.000            0.000\nChain 1:   6800       -39716.766             0.000            0.000\nChain 1:   6900       -39724.482             0.000            0.000\nChain 1:   7000       -39717.376             0.000            0.000\nChain 1:   7100       -39721.566             0.000            0.000\nChain 1:   7200       -39725.641             0.000            0.000\nChain 1:   7300       -39717.909             0.000            0.000\nChain 1:   7400       -39720.096             0.000            0.000\nChain 1:   7500       -39716.243             0.000            0.000\nChain 1:   7600       -39738.451             0.000            0.000\nChain 1:   7700       -39715.841             0.000            0.000\nChain 1:   7800       -39716.561             0.000            0.000\nChain 1:   7900       -39716.865             0.000            0.000\nChain 1:   8000       -39721.972             0.000            0.000\nChain 1:   8100       -39723.864             0.000            0.000\nChain 1:   8200       -39716.157             0.000            0.000\nChain 1:   8300       -39720.235             0.000            0.000\nChain 1:   8400       -39718.693             0.000            0.000\nChain 1:   8500       -39727.325             0.000            0.000\nChain 1:   8600       -39716.809             0.000            0.000\nChain 1:   8700       -39716.760             0.000            0.000\nChain 1:   8800       -39721.577             0.000            0.000\nChain 1:   8900       -39716.910             0.000            0.000\nChain 1:   9000       -39721.631             0.000            0.000\nChain 1:   9100       -39721.102             0.000            0.000\nChain 1:   9200       -39718.303             0.000            0.000\nChain 1:   9300       -39715.759             0.000            0.000\nChain 1:   9400       -39719.769             0.000            0.000\nChain 1:   9500       -39719.046             0.000            0.000\nChain 1:   9600       -39720.854             0.000            0.000\nChain 1:   9700       -39717.968             0.000            0.000\nChain 1:   9800       -39721.396             0.000            0.000\nChain 1:   9900       -39728.139             0.000            0.000\nChain 1:   10000       -39715.367             0.000            0.000\nChain 1: Informational Message: The maximum number of iterations is reached! The algorithm may not have converged.\nChain 1: This variational approximation is not guaranteed to be meaningful.\nChain 1: \nChain 1: Drawing a sample of size 1000 from the approximate posterior... \nChain 1: COMPLETED.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Pareto k diagnostic value is 2.05. Resampling is disabled. Decreasing\ntol_rel_obj may help if variational algorithm has terminated prematurely.\nOtherwise consider using sampling instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nSetting 'QR' to TRUE can often be helpful when using one of the variational inference algorithms. See the documentation for the 'QR' argument.\n```\n:::\n\n```{.r .cell-code}\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n256 sec elapsed\n```\n:::\n\n```{.r .cell-code}\nlower_tol_draws <- poststrat_df_60k %>% add_epred_draws(fit_60k_1e8, ndraws = 1000)\n\nmfvi_lower_tol_points <- lower_tol_draws %>% \n                        group_by(state,.draw) %>%\n                        summarize(postrat_draw = sum(.epred*(n/sum(n)))) %>%\n                        mutate(model = \"MF-VI 1e-8\")\n\ncombined_points_w_lower_tol <- combined_points %>%\n                      bind_rows(mfvi_lower_tol_points) %>%\n                      ungroup()\n\ncombined_points_w_lower_tol %>%\n  mutate(ordered_state = fct_reorder(combined_points_w_lower_tol$state,\n                                     combined_points_w_lower_tol$postrat_draw)) %>%\n  ggplot(aes(y = ordered_state,\n             x = postrat_draw,\n             color = model)) +\n     stat_dots(quantiles = 100) +\n     facet_wrap(~model) +\n     theme(legend.position=\"none\")\n```\n\n::: {.cell-output-display}\n![](Variational_MRP_pt2_files/figure-html/unnamed-chunk-6-1.png){width=768}\n:::\n:::\n\n... That certainly looks different, but I don't really think I'd say it looks\nmeaningfully better.\n\nLooking at the printed out ELBO, it's pretty clear that there was no traction\nafter the first ~1000 samples. A variational family this simple isn't going\nto get much better, no matter how much time you give it.\n\n## Full-Rank Approximation\n\nSo if extend training time, but improvements don't result, maybe the next\noption is ask whether we need something more sophisticated than a mean-field\napproximation. Instead of \n\n$$q(z) = \\prod_{j=1}^{m} q_j(z_j)$$\n\nlet's now try the full-rank approximation. Gather than each $z_j$ getting it's own\nindependent Gaussian, this uses a single multivariate normal distribution-\nso we can now (roughly) learn correlation structure, fancy.\n\n$$q(z) = \\mathcal{N}(z|\\mu,\\Sigma)$$\n\n::: {.cell warnings='false'}\n\n```{.r .cell-code}\ntic()\nfit_60k_fullrank <- stan_glmer(abortion ~ (1 | state) + (1 | eth) + (1 | educ) +\n                                      male + (1 | male:eth) + (1 | educ:age) +\n                                      (1 | educ:eth) + repvote + factor(region),\n  family = binomial(link = \"logit\"),\n  data = cces_all_df,\n  prior = normal(0, 1, autoscale = TRUE),\n  prior_covariance = decov(scale = 0.50),\n  adapt_delta = 0.99,\n  refresh = 0,\n  tol_rel_obj = 1e-8,\n  # Printing the ELBO every 1k draws\n  refresh = 1000,\n  algorithm = \"fullrank\",\n  QR = TRUE,\n  seed = 605)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Pareto k diagnostic value is 2.95. Resampling is disabled. Decreasing\ntol_rel_obj may help if variational algorithm has terminated prematurely.\nOtherwise consider using sampling instead.\n```\n:::\n\n```{.r .cell-code}\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n357.28 sec elapsed\n```\n:::\n\n```{.r .cell-code}\nfull_rank_draws <- poststrat_df_60k %>% add_epred_draws(fit_60k_fullrank,\n                                                        ndraws = 1000)\n\nfrvi_points <- full_rank_draws %>% \n                        group_by(state,.draw) %>%\n                        summarize(postrat_draw = sum(.epred*(n/sum(n)))) %>%\n                        mutate(model = \"FR-VI\")\n\ncombined_points_w_frvi <- combined_points_w_lower_tol %>%\n                      bind_rows(frvi_points) %>%\n                      ungroup()\n\ncombined_points_w_frvi %>%\n  mutate(ordered_state = fct_reorder(combined_points_w_frvi$state,\n                                     combined_points_w_frvi$postrat_draw)) %>%\n  ggplot(aes(y = ordered_state,\n             x = postrat_draw,\n             color = model)) +\n     stat_dots(quantiles = 100) +\n     facet_wrap(~model) +\n     theme(legend.position=\"none\")\n```\n\n::: {.cell-output-display}\n![](Variational_MRP_pt2_files/figure-html/unnamed-chunk-7-1.png){width=768}\n:::\n:::\n\nThe first thing to note here is that unlike the mean-field approximation, fitting\nthis model required some tinkering to get it to fit. I ended up needing to set\n`QR = TRUE` (ie, use a QR decomposition) to get this to fit at all (unless\nI set the initialization to 0, at which point the posterior collapsed to nearly)\na single point. \n\nUnfortunately, this version has a similar spiky posterior distribution. It might\neven be worse than the mean-field try. Again, it looks like \n\n# Where to from here? (Why is it like this!?)\n\n[^1]: Really, the worst type of wrong, completely unpredictable wrong. If you spend\ntime staring to try to infer a causal pattern of which states we can't estimate well,\nyou're likely just going to end up confused.\n[^2]: Some of these MFVI distributions are bad enough that you might reasonably\nwonder if some of the badness is just plotting weirdness. That was my intuition at\nfirst. Of course though, this is sufficient granularity to make the MCMC results\nlook reasonable. But even if you zoom in on 1 or two states and add way more\npoints, the improbably sharp spikes remain.\n[^3]: Phrase due to Richard McElreath. The magic of good visualizations like\nKay et Al.'s is that makes it trivial to let pattern recognition go to work,\nand be able to go \"oh, I don't believe that\".",
    "supporting": [
      "Variational_MRP_pt2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}