axis="both",
left=False,
top=False,
right=False,
bottom=False,
labelleft=False,
labeltop=False,
labelright=False,
labelbottom=False,
)
return ax
plot_density(U_1)
reticulate::repl_python()
#| echo: false
import torch
import numpy
import torch.nn as nn
from torch.distributions import Uniform
from torch.distributions import MultivariateNormal
from torch import Tensor
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
#| echo: false
import torch
import numpy
import torch.nn as nn
from torch.distributions import Uniform
from torch.distributions import MultivariateNormal
from torch import Tensor
#| echo: false
import torch
import numpy as np
import torch.nn as nn
from torch.distributions import Uniform
from torch.distributions import MultivariateNormal
from torch import Tensor
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
xlim=4
ylim=4
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
xlim=4
ylim=4
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2
xlim=4
ylim=4
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2
u
xlim=4
ylim=4
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
u
xlim=4
ylim=4
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2))
u
xlim=4
ylim=4
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((Z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((Z[:, 0] + 2) / 0.6) ** 2))
u
xlim=4
ylim=4
def density(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((Z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((Z[:, 0] + 2) / 0.6) ** 2))
U = torch.exp(-density(Z))
xlim=4
ylim=4
def density(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((Z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((Z[:, 0] + 2) / 0.6) ** 2))
U = torch.exp(-density(Z))
U
xlim=4
ylim=4
def density(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((Z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((Z[:, 0] + 2) / 0.6) ** 2))
U = torch.exp(-density(Z))
U.shape()
xlim=4
ylim=4
def density(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((Z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((Z[:, 0] + 2) / 0.6) ** 2))
U = torch.exp(-density(Z))
U.size()
xlim=4
ylim=4
def density(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((Z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((Z[:, 0] + 2) / 0.6) ** 2))
U = torch.exp(-density(Z))
U = U.reshape(shape)
U.size()
U
import torch
import numpy as np
import matplotlib.pyplot as plt
def U_1(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
def plot_density(density, xlim=4, ylim=4, ax=None, cmap="Purples"):
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
U = torch.exp(-density(Z))
U = U.reshape(shape)
if ax is None:
fig = plt.figure(figsize=(7, 7))
ax = fig.add_subplot(111)
ax.set_xlim(-xlim, xlim)
ax.set_ylim(-xlim, xlim)
ax.set_aspect(1)
ax.pcolormesh(X, Y, U, cmap=cmap, rasterized=True)
ax.tick_params(
axis="both",
left=False,
top=False,
right=False,
bottom=False,
labelleft=False,
labeltop=False,
labelright=False,
labelbottom=False,
)
return ax
plot_density(U_1)
xlim=4
ylim=4
def density(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((Z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((Z[:, 0] + 2) / 0.6) ** 2))
U = torch.exp(-density(Z))
U = U.reshape(shape)
U.size()
U
U.sum()
xlim=4
ylim=4
def density(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((Z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((Z[:, 0] + 2) / 0.6) ** 2))
U = torch.exp(-density(Z))
U = U.reshape(shape)
U.size()
U
xlim=4
ylim=4
def density(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((Z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((Z[:, 0] + 2) / 0.6) ** 2))
U = torch.exp(-density(Z))
U = U.reshape(shape)
U.size()
U
x
xlim=4
ylim=4
def density(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((Z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((Z[:, 0] + 2) / 0.6) ** 2))
U = torch.exp(-density(Z))
U = U.reshape(shape)
U.size()
U
x.size()
xlim=4
ylim=4
def density(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
u = 0.5 * ((torch.norm(Z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((Z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((Z[:, 0] + 2) / 0.6) ** 2))
U = torch.exp(-density(Z))
U = U.reshape(shape)
U.size()
U
x.shape
#| echo: false
import torch
import numpy as np
import torch.nn as nn
from torch.distributions import Uniform
from torch.distributions import MultivariateNormal
from torch import Tensor
from PIL import Image
raw_img = Image.open("images/hard_to_draw_posterior.png")
raw_img = Image.open("images/hard_to_draw_posterior.png")
print(image.format)
print(image.size)
print(image.mode)
raw_img = Image.open("images/hard_to_draw_posterior.png")
print(raw_img)
print(raw_img)
print(raw_img)
raw_img = Image.open("images/hard_to_draw_posterior.png")
numpydata = asarray(raw_img)
# <class 'numpy.ndarray'>
print(type(numpydata))
#  shape
print(numpydata.shape)
raw_img = Image.open("images/hard_to_draw_posterior.png")
numpydata = np.array(raw_img)
# <class 'numpy.ndarray'>
print(type(numpydata))
#  shape
print(numpydata.shape)
raw_img = Image.open("images/hard_to_draw_posterior.png")
raw_img = Image.open("images/hard_to_draw_posterior.png")
# Sum the 3 color channels
greyscale_img = np.array(raw_img).sum(axis = 2)
normalized_image  = (greyscale_img - greyscale_img()) / (greyscale_img.max() - greyscale_img())
# <class 'numpy.ndarray'>
print(type(numpydata))
#  shape
print(numpydata.shape)
raw_img = Image.open("images/hard_to_draw_posterior.png")
# Sum the 3 color channels
greyscale_img = np.array(raw_img).sum(axis = 2)
normalized_image  = (greyscale_img - greyscale_img()) / (greyscale_img.max() - greyscale_img.min())
# <class 'numpy.ndarray'>
print(type(numpydata))
#  shape
print(numpydata.shape)
raw_img = Image.open("images/hard_to_draw_posterior.png")
# Sum the 3 color channels
greyscale_img = np.array(raw_img).sum(axis = 2)
# Normalize values to help with fitting
normalized_image  = (greyscale_img - greyscale_img()) / (greyscale_img.max() - greyscale_img.min())
# <class 'numpy.ndarray'>
print(type(numpydata))
#  shape
print(numpydata.shape)
raw_img = Image.open("images/hard_to_draw_posterior.png")
# Sum the 3 color channels
greyscale_img = np.array(raw_img).sum(axis = 2)
# Normalize values to help with fitting
normalized_image  = (greyscale_img - greyscale_img.min()) / (greyscale_img.max() - greyscale_img.min())
# <class 'numpy.ndarray'>
print(type(numpydata))
#  shape
print(numpydata.shape)
View(normalized_image)
raw_img = Image.open("images/hard_to_draw_posterior.png")
# Sum the 3 color channels
greyscale_img = np.array(raw_img).sum(axis = 2)
greyscale_img.min()
# Normalize values to help with fitting
normalized_image  = (greyscale_img - greyscale_img.min()) / (greyscale_img.max() - greyscale_img.min())
# <class 'numpy.ndarray'>
print(type(numpydata))
#  shape
print(numpydata.shape)
raw_img = Image.open("images/hard_to_draw_posterior.png")
# Sum the 3 color channels
greyscale_img = np.array(raw_img).sum(axis = 2)
greyscale_img.min()
greyscale_img.max()
# Normalize values to help with fitting
normalized_image  = (greyscale_img - greyscale_img.min()) / (greyscale_img.max() - greyscale_img.min())
# <class 'numpy.ndarray'>
print(type(numpydata))
#  shape
print(numpydata.shape)
# Create a NumPy array
array = np.array([1, 2, 3, 4, 5])
# Normalize the array
normalized_array = (array - array.min()) / (array.max() - array.min())
print(normalized_array)
raw_img = Image.open("images/hard_to_draw_posterior.png")
# Sum the 3 color channels
greyscale_img = np.array(raw_img).sum(axis = 2)
greyscale_img.min()
greyscale_img.max()
# Normalize values to help with fitting
normalized_image  = (greyscale_img - greyscale_img.min()) / (greyscale_img.max() - greyscale_img.min())
# <class 'numpy.ndarray'>
print(type(normalized_image))
#  shape
print(normalized_image.shape)
raw_img = Image.open("images/hard_to_draw_posterior.png")
# Sum the 3 color channels
greyscale_img = np.array(raw_img).sum(axis = 2)
greyscale_img.min()
greyscale_img.max()
# Normalize values to help with fitting
normalized_image  = (greyscale_img - greyscale_img.min()) / (greyscale_img.max() - greyscale_img.min())
normalized_image.min()
normalized_image.max()
# <class 'numpy.ndarray'>
print(type(normalized_image))
#  shape
print(normalized_image.shape)
raw_img = Image.open("images/hard_to_draw_posterior.png")
# Sum the 3 color channels
greyscale_img = np.array(raw_img).sum(axis = 2)
# Normalize values to help with fitting
normalized_image  = (greyscale_img - greyscale_img.min()) / (greyscale_img.max() - greyscale_img.min())
# Make a torch tensor of the target to use
torch_posterior = torch.from_numpy(normalized_image)
torch_posterior.size
raw_img = Image.open("images/hard_to_draw_posterior.png")
# Sum the 3 color channels
greyscale_img = np.array(raw_img).sum(axis = 2)
# Normalize values to help with fitting
normalized_image  = (greyscale_img - greyscale_img.min()) / (greyscale_img.max() - greyscale_img.min())
# Make a torch tensor of the target to use
torch_posterior = torch.from_numpy(normalized_image)
torch_posterior.shape
# https://github.com/e-hulten/planar-flows/blob/master/loss.py
class VariationalLoss(nn.Module):
def __init__(self, distribution):
super().__init__()
self.distr = distribution
self.base_distr = MultivariateNormal(torch.zeros(2), torch.eye(2))
def forward(self, z0: Tensor, z: Tensor, sum_log_det_J: float) -> float:
base_log_prob = self.base_distr.log_prob(z0)
target_density_log_prob = -self.distr(z)
return (base_log_prob - target_density_log_prob - sum_log_det_J).mean()
# https://github.com/e-hulten/planar-flows/blob/master/loss.py
class VariationalLoss(nn.Module):
def __init__(self):
super().__init__()
self.distr = torch_posterior
self.base_distr = MultivariateNormal(torch.zeros(2), torch.eye(2))
def forward(self, z0: Tensor, z: Tensor, sum_log_det_J: float) -> float:
base_log_prob = self.base_distr.log_prob(z0)
target_density_log_prob = -self.distr(z)
return (base_log_prob - target_density_log_prob - sum_log_det_J).mean()
