# Create the 2D tensor using meshgrid
X, Y = torch.meshgrid(x, y)
# Print the resulting 2D tensor
print(X)
print(Y)
# Define the range and number of points in each dimension
# Define the size of the tensor
size = (10, 10)  # 10x10 tensor
# Generate the random tensor between 0 and 1
rand_tensor = torch.rand(size)
# Scale and shift the tensor to the desired range
min_val = 3
max_val = 4
scaled_tensor = rand_tensor * (max_val - min_val) + min_val
# Print the resulting tensor
print(scaled_tensor)
# Define the range and number of points in each dimension
# Define the size of the tensor
size = (10, 10)  # 10x10 tensor
# Generate the random tensor between 0 and 1
rand_tensor = torch.rand(size)
# Scale and shift the tensor to the desired range
min_val = 3
max_val = 4
scaled_tensor = rand_tensor * (max_val - min_val) + min_val
# Print the resulting tensor
print(scaled_tensor)
dim(scaled_tensor)
scaled_tensor.size()
# Define the range and number of points in each dimension
# Define the size of the tensor
size = (1000, 1000)  # 10x10 tensor
# Generate the random tensor between 0 and 1
rand_tensor = torch.rand(size)
# Scale and shift the tensor to the desired range
min_val = 3
max_val = 4
scaled_tensor = rand_tensor * (max_val - min_val) + min_val
# Print the resulting tensor
print(scaled_tensor)
scaled_tensor.size()
plt.plot(scaled_tensor.size().numpy(),output.cpu().numpy())
import matplotlib.pyplot as plt
plt.plot(scaled_tensor.size().numpy(),output.cpu().numpy())
reticulate::repl_python()
#| echo: false
import torch
import torch.nn as nn
from torch.distributions import Uniform
from torch.distributions import MultivariateNormal
from torch import Tensor
# Define the range and number of points in each dimension
# Define the size of the tensor
size = (1000, 1000)  # 10x10 tensor
# Generate the random tensor between 0 and 1
rand_tensor = torch.rand(size)
# Scale and shift the tensor to the desired range
min_val = 3
max_val = 4
scaled_tensor = rand_tensor * (max_val - min_val) + min_val
# Print the resulting tensor
print(scaled_tensor)
scaled_tensor.size()
import matplotlib.pyplot as plt
plt.plot(scaled_tensor.size().numpy(),output.cpu().numpy())
import matplotlib.pyplot as plt
plt.plot(scaled_tensor.cpu().numpy())
# Define the range and number of points in each dimension
# Define the size of the tensor
size = (10, 10)  # 10x10 tensor
# Generate the random tensor between 0 and 1
rand_tensor = torch.rand(size)
# Scale and shift the tensor to the desired range
min_val = 3
max_val = 4
scaled_tensor = rand_tensor * (max_val - min_val) + min_val
# Print the resulting tensor
print(scaled_tensor)
scaled_tensor.size()
tensor_test = scaled_tensor.cpu().numpy()
View(tensor_test)
tensor_test.size)
tensor_test.size()
tensor_test.shape()
numpy.shape(tensor_test)
#| echo: false
import torch
import numpy
import torch.nn as nn
from torch.distributions import Uniform
from torch.distributions import MultivariateNormal
from torch import Tensor
# Define the range and number of points in each dimension
# Define the size of the tensor
size = (10, 10)  # 10x10 tensor
# Generate the random tensor between 0 and 1
rand_tensor = torch.rand(size)
# Scale and shift the tensor to the desired range
min_val = 3
max_val = 4
scaled_tensor = rand_tensor * (max_val - min_val) + min_val
# Print the resulting tensor
print(scaled_tensor)
scaled_tensor.size()
tensor_test = scaled_tensor.cpu().numpy()
numpy.shape(tensor_test)
# Define the range and number of points in each dimension
# Define the size of the tensor
size = (1, 1)  # 10x10 tensor
# Generate the random tensor between 0 and 1
rand_tensor = torch.rand(size)
# Scale and shift the tensor to the desired range
min_val = 3
max_val = 4
scaled_tensor = rand_tensor * (max_val - min_val) + min_val
# Print the resulting tensor
print(scaled_tensor)
scaled_tensor.size()
tensor_test = scaled_tensor.cpu().numpy()
numpy.shape(tensor_test)
# Define the range and number of points in each dimension
# Define the size of the tensor
size = (1, 2)  # 10x10 tensor
# Generate the random tensor between 0 and 1
rand_tensor = torch.rand(size)
# Scale and shift the tensor to the desired range
min_val = 3
max_val = 4
scaled_tensor = rand_tensor * (max_val - min_val) + min_val
# Print the resulting tensor
print(scaled_tensor)
scaled_tensor.size()
tensor_test = scaled_tensor.cpu().numpy()
numpy.shape(tensor_test)
# Define the range and number of points in each dimension
# Define the size of the tensor
size = (1000, 2)  # 10x10 tensor
# Generate the random tensor between 0 and 1
rand_tensor = torch.rand(size)
# Scale and shift the tensor to the desired range
min_val = 3
max_val = 4
scaled_tensor = rand_tensor * (max_val - min_val) + min_val
# Print the resulting tensor
print(scaled_tensor)
scaled_tensor.size()
tensor_test = scaled_tensor.cpu().numpy()
numpy.shape(tensor_test)
# Define the range and number of points in each dimension
# Define the size of the tensor
size = (2, 1000)  # 10x10 tensor
# Generate the random tensor between 0 and 1
rand_tensor = torch.rand(size)
# Scale and shift the tensor to the desired range
min_val = 3
max_val = 4
scaled_tensor = rand_tensor * (max_val - min_val) + min_val
# Print the resulting tensor
print(scaled_tensor)
scaled_tensor.size()
tensor_test = scaled_tensor.cpu().numpy()
numpy.shape(tensor_test)
reticulate::repl_python()
import seaborn as sns
sns.kdeplot(
data=geyser, x="waiting", y="duration",
fill=True, thresh=0, levels=100, cmap="mako",
)
import seaborn as sns
geyser = sns.load_dataset("geyser")
sns.kdeplot(
data=geyser, x="waiting", y="duration",
fill=True, thresh=0, levels=100, cmap="mako",
)
reticulate::repl_python()
#| echo: false
import torch
import numpy
import torch.nn as nn
from torch.distributions import Uniform
from torch.distributions import MultivariateNormal
from torch import Tensor
m = Uniform(torch.tensor([0.0]), torch.tensor([5.0]))
m = Uniform(torch.tensor([0.0]), torch.tensor([5.0]))
m
m = Uniform(torch.tensor([0.0]), torch.tensor([5.0]))
m.sample()
m = Uniform(torch.tensor([0.0]), torch.tensor([5.0]))
m.sample()
m = Uniform(torch.tensor([0.0]), torch.tensor([5.0]))
m.sample()
m = Uniform(torch.tensor([0.0]), torch.tensor([5.0]))
m.sample()
m = Uniform(torch.tensor([0.0]), torch.tensor([5.0]))
m.sample()
m = Uniform(torch.tensor([3.0,4.0]), torch.tensor([3.0,4.0]))
m.sample()
m = Uniform(torch.tensor([3.0,4.0]), torch.tensor([4.0,5.0]))
m.sample()
m = Uniform(torch.tensor([3.0,4.0]), torch.tensor([4.0,5.0]))
m.sample()
a = 3, b = 4
(a - b)*torch.rand(2, 1000) + b
a = 3; b = 4
(a - b)*torch.rand(2, 1000) + b
a = 3; b = 4
(a - b)*torch.rand(1000, 2) + b
def get_target_distribution(name: str) -> Callable[[Tensor], Tensor]:
w1 = lambda z: torch.sin(2 * np.pi * z[:, 0] / 4)
w2 = lambda z: 3 * torch.exp(-0.5 * ((z[:, 0] - 1) / 0.6) ** 2)
w3 = lambda z: 3 * torch.sigmoid((z[:, 0] - 1) / 0.3)
if name == "U_1":
def U_1(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
def get_target_distribution(name: str):
w1 = lambda z: torch.sin(2 * np.pi * z[:, 0] / 4)
w2 = lambda z: 3 * torch.exp(-0.5 * ((z[:, 0] - 1) / 0.6) ** 2)
w3 = lambda z: 3 * torch.sigmoid((z[:, 0] - 1) / 0.3)
if name == "U_1":
def U_1(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
def get_target_distribution(name):
w1 = lambda z: torch.sin(2 * np.pi * z[:, 0] / 4)
w2 = lambda z: 3 * torch.exp(-0.5 * ((z[:, 0] - 1) / 0.6) ** 2)
w3 = lambda z: 3 * torch.sigmoid((z[:, 0] - 1) / 0.3)
if name == "U_1":
def U_1(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
name = "U_1"
def get_target_distribution(name):
w1 = lambda z: torch.sin(2 * np.pi * z[:, 0] / 4)
w2 = lambda z: 3 * torch.exp(-0.5 * ((z[:, 0] - 1) / 0.6) ** 2)
w3 = lambda z: 3 * torch.sigmoid((z[:, 0] - 1) / 0.3)
if name == "U_1":
def U_1(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
name = "U_1"
def get_target_distribution(name):
w1 = lambda z: torch.sin(2 * np.pi * z[:, 0] / 4)
w2 = lambda z: 3 * torch.exp(-0.5 * ((z[:, 0] - 1) / 0.6) ** 2)
w3 = lambda z: 3 * torch.sigmoid((z[:, 0] - 1) / 0.3)
if name == "U_1":
def U_1(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
name = "U_1"
def get_target_distribution(name):
w1 = lambda z: torch.sin(2 * np.pi * z[:, 0] / 4)
w2 = lambda z: 3 * torch.exp(-0.5 * ((z[:, 0] - 1) / 0.6) ** 2)
w3 = lambda z: 3 * torch.sigmoid((z[:, 0] - 1) / 0.3)
if name == "U_1":
def U_1(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
get_target_distribution("U_1")
name = "U_1"
def get_target_distribution(name):
w1 = lambda z: torch.sin(2 * np.pi * z[:, 0] / 4)
w2 = lambda z: 3 * torch.exp(-0.5 * ((z[:, 0] - 1) / 0.6) ** 2)
w3 = lambda z: 3 * torch.sigmoid((z[:, 0] - 1) / 0.3)
if name == "U_1":
def U_1(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
print(get_target_distribution("U_1"))
name = "U_1"
def get_target_distribution(name):
w1 = lambda z: torch.sin(2 * np.pi * z[:, 0] / 4)
w2 = lambda z: 3 * torch.exp(-0.5 * ((z[:, 0] - 1) / 0.6) ** 2)
w3 = lambda z: 3 * torch.sigmoid((z[:, 0] - 1) / 0.3)
if name == "U_1":
def U_1(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
x = get_target_distribution("U_1")
x
base_distr = MultivariateNormal(torch.zeros(2), torch.eye(2))
base_distr.sample()
base_distr = MultivariateNormal(torch.zeros(2), torch.eye(2))
base_distr.sample()
base_distr = MultivariateNormal(torch.zeros(2), torch.eye(2))
base_distr.sample()
base_distr = MultivariateNormal(torch.zeros(2), torch.eye(2))
base_distr.sample()
base_distr = MultivariateNormal(torch.zeros(2), torch.eye(2))
base_distr.sample()
base_distr = MultivariateNormal(torch.zeros(2), torch.eye(2))
base_distr.sample()
a = 0; b = 1
(a - b)*torch.rand(1000, 2) + b
a = 0; b = 1
((a - b)*torch.rand(1000, 2) + b) +1
a = 0; b = 1
(a - b)*torch.rand(1000, 2) + b
def plot_density(density, xlim=4, ylim=4, ax=None, cmap="Blues"):
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
U = torch.exp(-density(Z))
U = U.reshape(shape)
if ax is None:
fig = plt.figure(figsize=(7, 7))
ax = fig.add_subplot(111)
ax.set_xlim(-xlim, xlim)
ax.set_ylim(-xlim, xlim)
ax.set_aspect(1)
ax.pcolormesh(X, Y, U, cmap=cmap, rasterized=True)
ax.tick_params(
axis="both",
left=False,
top=False,
right=False,
bottom=False,
labelleft=False,
labeltop=False,
labelright=False,
labelbottom=False,
)
return ax
def plot_density(density, xlim=4, ylim=4, ax=None, cmap="Blues"):
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
U = torch.exp(-density(Z))
U = U.reshape(shape)
if ax is None:
fig = plt.figure(figsize=(7, 7))
ax = fig.add_subplot(111)
ax.set_xlim(-xlim, xlim)
ax.set_ylim(-xlim, xlim)
ax.set_aspect(1)
ax.pcolormesh(X, Y, U, cmap=cmap, rasterized=True)
ax.tick_params(
axis="both",
left=False,
top=False,
right=False,
bottom=False,
labelleft=False,
labeltop=False,
labelright=False,
labelbottom=False,
)
return ax
def plot_density(density, xlim=4, ylim=4, ax=None, cmap="Blues"):
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
U = torch.exp(-density(Z))
U = U.reshape(shape)
if ax is None:
fig = plt.figure(figsize=(7, 7))
ax = fig.add_subplot(111)
ax.set_xlim(-xlim, xlim)
ax.set_ylim(-xlim, xlim)
ax.set_aspect(1)
ax.pcolormesh(X, Y, U, cmap=cmap, rasterized=True)
ax.tick_params(
axis="both",
left=False,
top=False,
right=False,
bottom=False,
labelleft=False,
labeltop=False,
labelright=False,
labelbottom=False,
)
return ax
import torch
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats.kde import gaussian_kde
def plot_density(density, xlim=4, ylim=4, ax=None, cmap="Blues"):
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
U = torch.exp(-density(Z))
U = U.reshape(shape)
if ax is None:
fig = plt.figure(figsize=(7, 7))
ax = fig.add_subplot(111)
ax.set_xlim(-xlim, xlim)
ax.set_ylim(-xlim, xlim)
ax.set_aspect(1)
ax.pcolormesh(X, Y, U, cmap=cmap, rasterized=True)
ax.tick_params(
axis="both",
left=False,
top=False,
right=False,
bottom=False,
labelleft=False,
labeltop=False,
labelright=False,
labelbottom=False,
)
return ax
import torch
import numpy as np
import matplotlib.pyplot as plt
dens = MultivariateNormal(torch.zeros(2), torch.eye(2))
def plot_density(density, xlim=4, ylim=4, ax=None, cmap="Blues"):
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
U = torch.exp(-density(Z))
U = U.reshape(shape)
if ax is None:
fig = plt.figure(figsize=(7, 7))
ax = fig.add_subplot(111)
ax.set_xlim(-xlim, xlim)
ax.set_ylim(-xlim, xlim)
ax.set_aspect(1)
ax.pcolormesh(X, Y, U, cmap=cmap, rasterized=True)
ax.tick_params(
axis="both",
left=False,
top=False,
right=False,
bottom=False,
labelleft=False,
labeltop=False,
labelright=False,
labelbottom=False,
)
return ax
plot_density(dens)
import torch
import numpy as np
import matplotlib.pyplot as plt
def U_1(z):
u = 0.5 * ((torch.norm(z, 2, dim=1) - 2) / 0.4) ** 2
u = u - torch.log(
torch.exp(-0.5 * ((z[:, 0] - 2) / 0.6) ** 2)
+ torch.exp(-0.5 * ((z[:, 0] + 2) / 0.6) ** 2)
)
return u
def plot_density(density, xlim=4, ylim=4, ax=None, cmap="Blues"):
x = y = np.linspace(-xlim, xlim, 300)
X, Y = np.meshgrid(x, y)
shape = X.shape
X_flatten, Y_flatten = np.reshape(X, (-1, 1)), np.reshape(Y, (-1, 1))
Z = torch.from_numpy(np.concatenate([X_flatten, Y_flatten], 1))
U = torch.exp(-density(Z))
U = U.reshape(shape)
if ax is None:
fig = plt.figure(figsize=(7, 7))
ax = fig.add_subplot(111)
ax.set_xlim(-xlim, xlim)
ax.set_ylim(-xlim, xlim)
ax.set_aspect(1)
ax.pcolormesh(X, Y, U, cmap=cmap, rasterized=True)
ax.tick_params(
axis="both",
left=False,
top=False,
right=False,
bottom=False,
labelleft=False,
labeltop=False,
labelright=False,
labelbottom=False,
)
return ax
plot_density(U_1)
